import hassapi as hass
from datetime import datetime, timedelta
import numpy as np

class hvacControl(hass.Hass):
    def initialize(self):
        self.calculate_adjustment(skip_state_check=True)
        self.run_in(self.start_run_every, 1)  # Start run_every after 1 second
        self.listen_state(self.calculate_classification_adjustment, "sensor.electricity_twoday_classification")
        self.calculate_classification_adjustment(skip_state_check=True)
        self.run_in(self.start_run_every_15, 1)  # Start run_every_15 after 1 second

    def start_run_every_15(self, kwargs):
        now = datetime.now()
        minutes = (now.minute // 15 + 1) * 15
        if minutes >= 60:
            minutes = 0
        start_time = now.replace(minute=minutes, second=0, microsecond=0)
        if minutes == 0:
            start_time += timedelta(hours=1)
        self.run_every(self.update_weighed_price_range, start_time, 15*60)  # Run every 15 minutes

    def start_run_every(self, kwargs):
        now = datetime.now()
        minutes = (now.minute // 5 + 1) * 5
        if minutes >= 60:
            minutes = 0
        start_time = now.replace(minute=minutes, second=0, microsecond=0)
        if minutes == 0:
            start_time += timedelta(hours=1)
        self.run_every(self.calculate_adjustment, start_time, 5*60)  # Run every 5 minutes

    def calculate_adjustment(self, entity=None, attribute=None, old=None, new=None, kwargs=None, skip_state_check=False, now=None):
        prices_today = self.get_state("sensor.nordpool_kwh_se4_sek_3_10_025", attribute="today")
        current_price = self.get_state("sensor.nordpool_kwh_se4_sek_3_10_025", attribute="current_price")
        
        if not prices_today or current_price is None:  # Check if the list is empty or current_price is None
            self.log("No data available for today or current price. Using default values for adjustment calculation.")
            current_price = 0
            lowest_price = 0
            highest_price = 1
        else:
            prices_sorted = sorted(prices_today)
            lowest_price = min(prices_sorted)
            highest_price = max(prices_sorted)

        # Calculate the adjustment percentage linearly from the absolute highest price to the absolute lowest price
        # Adjust the range from +100% to -100%
        adjustment_percentage = round(((highest_price - current_price) / (highest_price - lowest_price)) * 200 - 100)

        self.log(f"Current price: {current_price}, Lowest price: {lowest_price}, Highest price: {highest_price}, Adjustment percentage: {adjustment_percentage}")

        self.set_state("sensor.electricity_PriceOptSignal", state=adjustment_percentage, attributes={"unit_of_measurement": "%"})
        
        self.log(f"Updated state: {self.get_state('sensor.electricity_PriceOptSignal')}")

    def calculate_classification_adjustment(self, entity=None, attribute=None, old=None, new=None, kwargs=None, skip_state_check=False):
        classification = self.get_state("sensor.electricity_twoday_classification")
        if not classification:  # Check if the state is empty
            self.log("No data available for two-day classification. Skipping adjustment calculation.")
            return

        # Extract the class number from the state
        class_number = int(classification.split(" ")[1])

        # Calculate the adjustment percentage linearly from class 5 to class 1
        # Adjust the range from +100% to -100%
        adjustment_percentage = 100 - (class_number - 1) * 50

        self.set_state("sensor.electricity_ClassificationOptSignal", state=adjustment_percentage, attributes={"unit_of_measurement": "%"})

    def update_weighed_price_range(self, kwargs):
        # Fetch the current price from the sensor
        current_price = self.get_state("sensor.nordpool_kwh_se4_sek_3_10_025", attribute="current_price")

        # Fetch the prices for today from the sensor
        prices_today = self.get_state("sensor.nordpool_kwh_se4_sek_3_10_025", attribute="today")

        if not prices_today or current_price is None:  # Check if the list is empty or current_price is None
            self.log("No data available for today or current price. Using default values for adjustment calculation.")
            current_price = 0
            prices = [0, 1]
        else:
            prices = sorted(prices_today)

        # The rest of your code...
        # Calculate the 25% lowest and highest prices
        prices_sorted = sorted(prices)
        lower_25_percentile = np.percentile(prices_sorted, 25)
        upper_25_percentile = np.percentile(prices_sorted, 75)

        # Define the ranges
        lowest_range = (min(prices_sorted), lower_25_percentile)
        lower_middle_range = (lower_25_percentile, average_price)
        upper_middle_range = (average_price, upper_25_percentile)
        highest_range = (upper_25_percentile, max(prices_sorted))

        # Define the current range according to the current price
        if current_price <= lower_25_percentile:
            current_range = "Lowest range"
        elif current_price <= average_price:
            current_range = "Lower-middle range"
        elif current_price <= upper_25_percentile:
            current_range = "Upper-middle range"
        else:
            current_range = "Highest range"

        # Define the sensor entity
        sensor_entity = "sensor.weighed_price_range"

        # Set the state and attributes of the sensor
        self.set_state(sensor_entity, state=average_price, attributes={
                "device_class": "measurement",
                "unit_of_measurement": "SEK",
                "25% lowest price": lower_25_percentile,
                "25% highest price": upper_25_percentile,
                "Average price": average_price,
                "Lowest range": lowest_range,
                "Lower-middle range": lower_middle_range,
                "Upper-middle range": upper_middle_range,
                "Highest range": highest_range,
                "Current pricerange": current_range,  # Add the current range as an attribute
            })