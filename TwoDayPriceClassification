import numpy as np
from datetime import datetime, time
from appdaemon.plugins.hass.hassapi import Hass

STATE_UNKNOWN = 'unknown'

class TwoDayPriceClassification(Hass):
    def initialize(self):
        # Schedule the update method to run every hour
        self.run_hourly(self.update, time(minute=0, second=0))

    def relative_classification(self, today_prices, tomorrow_prices):
        # Calculate the difference between today's and tomorrow's prices
        price_difference = np.array(today_prices) - np.array(tomorrow_prices)
        # Set the state of the sensor
        self.set_state('sensor.Electricity_TwoDay_classification_relative', state=price_difference.tolist())

    def dynamic_classification(self, today_prices, tomorrow_prices):
        # Calculate the difference between today's and tomorrow's prices
        price_difference = np.array(tomorrow_prices) - np.array(today_prices)
        # Classify the prices based on whether they are increasing or decreasing
        classified_prices_dynamic = ['increasing' if change > 0 else 'decreasing' for change in price_difference]
        # Set the state of the sensor
        self.set_state('sensor.Electricity_TwoDay_classification_dynamic', state=classified_prices_dynamic)

    def weighted_classification(self, today_prices, tomorrow_prices):
        # Define the weights for today's and tomorrow's prices
        weights = [0.5, 0.5]  # This means both today's and tomorrow's prices have equal weight
        # Calculate the weighted average of today's and tomorrow's prices
        classified_prices_weighted = np.average([today_prices, tomorrow_prices], axis=0, weights=weights)
        # Set the state of the sensor
        self.set_state('sensor.Electricity_TwoDay_classification_weighted', state=classified_prices_weighted.tolist())

    def update(self, kwargs):
        # Fetch today's prices from your sensor
        today_prices = self.get_state('sensor.nordpool_kwh_se4_sek_3_10_025', attribute='today')

        # Check if the sensor data is valid
        if today_prices == STATE_UNKNOWN:
            self.log("Today's sensor data is not available")
            return

        # Convert the prices from string to float and replace 'unknown' with np.nan
        if isinstance(today_prices, list):
            today_prices = [float(price) if price != 'unknown' else np.nan for price in today_prices]
        else:
            today_prices = [float(price) if price != 'unknown' else np.nan for price in today_prices.split(',')]

        # Fetch tomorrow's prices from your sensor
        tomorrow_prices_partial = self.get_state('sensor.nordpool_kwh_se4_sek_3_10_025', attribute='tomorrow')

        # Fetch the validity of tomorrow's prices
        tomorrow_valid = self.get_state('sensor.nordpool_kwh_se4_sek_3_10_025', attribute='tomorrow_valid')

        # If tomorrow's prices are valid, wait until the current time is after 13:00 and then use them in the calculations
        if tomorrow_valid and datetime.now().hour >= 13:
            # Convert tomorrow's prices from string to float and replace 'unknown' with np.nan
            if isinstance(tomorrow_prices_partial, list):
                tomorrow_prices_partial = [float(price) if price != 'unknown' else np.nan for price in tomorrow_prices_partial]
            else:
                tomorrow_prices_partial = [float(price) if price != 'unknown' else np.nan for price in tomorrow_prices_partial.split(',')]